#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// ----------------- Pin assignments -----------------
const int togglePins[3] = {1, 2, 3};   // toggles: active LOW (connected to GND)
const int ledPins[3]    = {41, 40, 39}; // LEDs

// ----------------- Audio objects -----------------
const int MY_INPUT = AUDIO_INPUT_LINEIN;

AudioInputI2S       audioInput;

// TWO cascaded bass shelves
AudioFilterBiquad   bassBoost1;
AudioFilterBiquad   bassBoost2;

// Reverb + mixer
AudioEffectReverb   reverb;
AudioMixer4         reverbMixer;

// ----------- TREMOLO EFFECT -----------
// Multiply audio by an LFO
AudioEffectMultiply tremoloMultiplier;

// LFO generator (0–1 saw/sine/etc)
AudioSynthWaveform  tremoloLFO;

// Converts LFO from bipolar (-1..1) to unipolar (0..1)
AudioMixer4         tremoloOffsetMixer;  
// ---------------------------------------

AudioOutputI2S      audioOutput;
AudioControlSGTL5000 audioShield;

// dynamic patch cables
AudioConnection* patch[30];

// Which effects are on {bass, reverb, tremolo}
bool effectActive[3] = {false, false, false};

// Debounce
unsigned long lastToggleTime[3] = {0,0,0};
bool lastToggleRaw[3] = {HIGH, HIGH, HIGH};
const unsigned long debounceMs = 20;

// Reverb wet level
float reverbWet = 1.0f;

// Bass parameters
float bassGain1 = 10.0f;   
float bassGain2 = 14.0f;   
float bassFreq  = 60.0f;   
float bassQ     = 0.7f;    

void deleteAllConnections() {
  for (int i = 0; i < 30; i++) {
    if (patch[i]) {
      delete patch[i];
      patch[i] = nullptr;
    }
  }
}

void setupBassFilters() {
  bassBoost1.setLowShelf(0, bassFreq, bassQ, bassGain1);
  bassBoost2.setLowShelf(0, bassFreq, bassQ, bassGain2);
}

void setupTremolo() {
  // Configure LFO
  tremoloLFO.begin(WAVEFORM_SINE);
  tremoloLFO.frequency(4.0f);   // Tremolo speed (Hz)
  tremoloLFO.amplitude(1.0f);   // Output = -1 to +1

  // Offset mixer to shift LFO from -1..+1 to 0..1
  tremoloOffsetMixer.gain(0, 0.5f);   // (LFO * 0.5) + 0.5
  tremoloOffsetMixer.gain(1, 0.5f);   // Inject DC offset = +0.5

  // mixer inputs:
  // ch0: LFO
  // ch1: DC (use constant gain)
  // we need to feed ch1 with a constant 1.0
  // so we use waveform set to DC:
}

// Build the DSP routing graph
void setupAudioConnections() {
  AudioNoInterrupts();
  deleteAllConnections();

  int n = 0;
  AudioStream* current = &audioInput;

  // ---------- BASS BOOST BLOCK ----------
  if (effectActive[0]) {
    patch[n++] = new AudioConnection(*current, 0, bassBoost1, 0);
    current = &bassBoost1;

    patch[n++] = new AudioConnection(*current, 0, bassBoost2, 0);
    current = &bassBoost2;
  }

  // ---------- REVERB BLOCK (dry + wet) ----------
  if (effectActive[1]) {
    patch[n++] = new AudioConnection(*current, 0, reverb, 0);
    patch[n++] = new AudioConnection(*current, 0, reverbMixer, 0);
    patch[n++] = new AudioConnection(reverb, 0, reverbMixer, 1);

    reverbMixer.gain(0, 1.0f);
    reverbMixer.gain(1, reverbWet);

    current = &reverbMixer;
  }

  // ---------- TREMOLO EFFECT ----------
  if (effectActive[2]) {

    // current audio → multiplier input 0
    patch[n++] = new AudioConnection(*current, 0, tremoloMultiplier, 0);

    // LFO → offset mixer → multiplier input 1
    patch[n++] = new AudioConnection(tremoloLFO, 0, tremoloOffsetMixer, 0);

    // Constant DC offset to convert -1..1 into 0..1
    // We use waveform saw at constant value:
    static AudioSynthWaveform dcSource;
    dcSource.begin(WAVEFORM_SINE);
    dcSource.amplitude(1.0f);

    patch[n++] = new AudioConnection(dcSource, 0, tremoloOffsetMixer, 1);

    // Offset mixer → multiplier control
    patch[n++] = new AudioConnection(tremoloOffsetMixer, 0, tremoloMultiplier, 1);

    current = &tremoloMultiplier;
  }

  // ---------- OUTPUT ----------
  patch[n++] = new AudioConnection(*current, 0, audioOutput, 0);
  patch[n++] = new AudioConnection(*current, 0, audioOutput, 1);

  AudioInterrupts();
}

void setup() {
  Serial.begin(115200);
  delay(20);

  for (int i = 0; i < 3; i++) {
    pinMode(togglePins[i], INPUT_PULLUP);
    pinMode(ledPins[i], OUTPUT);
    digitalWrite(ledPins[i], LOW);
    lastToggleRaw[i] = digitalRead(togglePins[i]);
  }

  AudioMemory(30);

  audioShield.enable();
  delay(50);
  audioShield.inputSelect(MY_INPUT);
  audioShield.lineInLevel(2);
  audioShield.volume(0.85);

  setupBassFilters();
  setupTremolo();

  reverb.reverbTime(1.2f);

  setupAudioConnections();
}

void loop() {
  bool changed = false;

  for (int i = 0; i < 3; i++) {
    bool raw = digitalRead(togglePins[i]);

    if (raw != lastToggleRaw[i]) {
      lastToggleTime[i] = millis();
      lastToggleRaw[i] = raw;
    } else {
      if (millis() - lastToggleTime[i] > debounceMs) {
        bool active = !raw;

        if (active != effectActive[i]) {
          effectActive[i] = active;
          digitalWrite(ledPins[i], active ? HIGH : LOW);
          changed = true;
        }
      }
    }
  }

  if (changed) setupAudioConnections();

  delay(10);
}
